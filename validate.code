import "utils/pack/pack128.code" as pack128
import "utils/pack/unpack128.code" as unpack128
import "hashes/sha256/1024bit.code" as sha256for1024
import "./sha256only.code" as sha256only
import "./euclidian_division.code" as floor

def toBigEndian(field[32] value) -> (field[32]):
    return [ \
            ...value[24..32], \
            ...value[16..24], \
            ...value[8..16], \
            ...value[0..8]]

def toBigEndian(field[24] value) -> (field[24]):
    return [ \
            ...value[16..24], \
            ...value[8..16], \
            ...value[0..8]]

def toBigEndian(field[128] value) -> (field[128]):
    return [ \
            ...value[120..128], \
            ...value[112..120], \
            ...value[104..112], \
            ...value[96..104], \
            ...value[88..96], \
            ...value[80..88], \
            ...value[72..80], \
            ...value[64..72], \
            ...value[56..64], \
            ...value[48..56], \
            ...value[40..48], \
            ...value[32..40], \
            ...value[24..32], \
            ...value[16..24], \
            ...value[8..16], \
            ...value[0..8]]

def packTarget(field[32] bits) -> (field):
    field result = \
    if pack128([...[0; 120], ...bits[0..8]]) == 23 then pack128([...[0; 72], ...bits[8..32], ...[0; 32]]) else \
      if pack128([...[0; 120], ...bits[0..8]]) == 24 then pack128([...[0; 64], ...bits[8..32], ...[0; 40]]) else \
        if pack128([...[0; 120], ...bits[0..8]]) == 25 then pack128([...[0; 56], ...bits[8..32], ...[0; 48]]) else \
          if pack128([...[0; 120], ...bits[0..8]]) == 26 then pack128([...[0; 48], ...bits[8..32], ...[0; 56]]) else \
            if pack128([...[0; 120], ...bits[0..8]]) == 27 then pack128([...[0; 40], ...bits[8..32], ...[0; 64]]) else \
              if pack128([...[0; 120], ...bits[0..8]]) == 28 then pack128([...[0; 32], ...bits[8..32], ...[0; 72]]) else \
                if pack128([...[0; 120], ...bits[0..8]]) == 29 then pack128([...[0; 24], ...bits[8..32], ...[0; 80]]) else \
                  if pack128([...[0; 120], ...bits[0..8]]) == 30 then pack128([...[0; 16], ...bits[8..32], ...[0; 88]]) else \
                    if pack128([...[0; 120], ...bits[0..8]]) == 31 then pack128([...[0; 8], ...bits[8..32], ...[0; 96]]) else \
                    pack128([0; 128]) fi \
                  fi \
                fi \
              fi \
            fi \
          fi \
        fi \
      fi \
    fi
    return result

// call with last field of block array
def calculate_target(field epoch_head, field epoch_tail) -> (field):
    epoch_head_unpacked = unpack128(epoch_head)
    epoch_tail_unpacked = unpack128(epoch_tail)
    time_head = pack128([...[0; 96], ...toBigEndian(epoch_head_unpacked[32..64])])
    time_tail = pack128([...[0; 96], ...toBigEndian(epoch_tail_unpacked[32..64])])
    /*
    nonce_prefix_head = unpack128(epoch_head_unpacked[64..72])-128
    nonce_prefix = unpack128(epoch_tail_unpacked[64..72])-128 // 128 is subtracted to fit in a single variable, check if this is viable!
    nonce_base_head = unpack128(epoch_head_unpacked[72..96])
    nonce_base = unpack128(epoch_tail_unpacked[72..96])
    */

    current_target = packTarget(toBigEndian(epoch_head_unpacked[64..96]))
    field time_delta = time_tail - time_head
    field target_time_delta = 1209600 // 2016 * 600 (time interval of 10 minutes)

    //field target = current_target * time_delta // / target_time_delta
    field target = floor(current_target * time_delta, target_time_delta)

return target


def validate_block_header(field[2] prev_block_hash, field[5] preimage) -> (field[3]):
	a = unpack128(preimage[0])
	b = unpack128(preimage[1])
	c = unpack128(preimage[2])
	d = unpack128(preimage[3])
	e = unpack128(preimage[4])

    encoded_prev_block_hash1 = pack128([...a[32..128], ...b[0..32]])
    encoded_prev_block_hash2 = pack128([...b[32..128], ...c[0..32]])
    field valid = if encoded_prev_block_hash1 == prev_block_hash[0] && encoded_prev_block_hash2 == prev_block_hash[1] \
        then 1 else 0 fi

    field[256] preimage1 = [...a, ...b]
    field[256] preimage2 = [...c, ...d]
    field[256] preimage3 = [...[...e, 1], ...[0; 127]]
    field[256] dummy = [...[0; 246], ...[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]] //second array indicates length of preimage = 640bit

    intermediary = sha256for1024(preimage1, preimage2, preimage3, dummy)

    r = sha256only(intermediary)

    res0 = pack128(r[0..128])
    res1 = pack128(r[128..256])

    target = packTarget(toBigEndian(e[64..96]))

    valid = if valid == 1 && target > pack128(toBigEndian(r[128..256])) then 1 else 0 fi

return [valid, res0, res1]
//return [valid, target, pack128(toBigEndian(r[128..256]))] //output for test purposes

def main(field[5] prev_block, field[5] current_block, field[5] next_block) -> (field[3]):
    calculated_target = calculate_target(prev_block[4], current_block[4])
    unpacked_field = unpack128(next_block[4])
    field target_time_delta = 1209600 // 2016 * 600 (time interval of 10 minutes)
    field encoded_target = packTarget(toBigEndian(unpacked_field[64..96]))
    field encoded_target_extended = encoded_target * target_time_delta

return [0, encoded_target_extended, calculated_target]

/*
def mainly_garbage(field[2] prev_block_hash, prev_target, private field[20] intermediate_blocks, field[5] final_block) -> (field[3]):

    field result = 1

    block1 = validate_block_header(prev_block_hash, intermediate_blocks[0..5])
    result = if block1[0] == 0 || result == 0 then 0 else 1 fi

    block2 = validate_block_header(block1[1..3], intermediate_blocks[5..10])
    result = if block2[0] == 0 || result == 0 then 0 else 1 fi

    block3 = validate_block_header(block2[1..3], intermediate_blocks[10..15])
    result = if block3[0] == 0 || result == 0 then 0 else 1 fi

    block4 = validate_block_header(block3[1..3], intermediate_blocks[15..20])
    result = if block4[0] == 0 || result == 0 then 0 else 1 fi

    block5 = validate_block_header(block4[1..3], final_block)
    result = if block5[0] == 0 || result == 0 then 0 else 1 fi

return [result, ...block5[1..3]]
*/