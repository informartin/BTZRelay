import "utils/pack/pack128.code" as pack128
import "utils/pack/unpack128.code" as unpack128
import "hashes/sha256/1024bit.code" as sha256for1024
import "./sha256only.code" as sha256only

def toBigEndian(field[32] value) -> (field[32]):
    return [ \
            ...value[24..32], \
            ...value[16..24], \
            ...value[8..16], \
            ...value[0..8]]

def toBigEndian(field[24] value) -> (field[24]):
    return [ \
            ...value[16..24], \
            ...value[8..16], \
            ...value[0..8]]

def toBigEndian(field[128] value) -> (field[128]):
    return [ \
            ...value[120..128], \
            ...value[112..120], \
            ...value[104..112], \
            ...value[96..104], \
            ...value[88..96], \
            ...value[80..88], \
            ...value[72..80], \
            ...value[64..72], \
            ...value[56..64], \
            ...value[48..56], \
            ...value[40..48], \
            ...value[32..40], \
            ...value[24..32], \
            ...value[16..24], \
            ...value[8..16], \
            ...value[0..8]]

def unpackBits(field[32] bits) -> (field):
    field result =  if pack128([...[0; 120], ...bits[0..8]]) == 29 then pack128([...[0; 24], ...bits[8..32], ...[0; 80]]) else \
        if pack128([...[0; 120], ...bits[0..8]]) == 23 then pack128([...[0; 72], ...bits[8..32], ...[0; 32]]) else pack128([1; 128]) fi \
    fi
    return result


def validate_block_header(field[2] prev_block_hash, field[5] preimage) -> (field[3]):
	a = unpack128(preimage[0])
	b = unpack128(preimage[1])
	c = unpack128(preimage[2])
	d = unpack128(preimage[3])
	e = unpack128(preimage[4])

    encoded_prev_block_hash1 = pack128([...a[32..128], ...b[0..32]])
    encoded_prev_block_hash2 = pack128([...b[32..128], ...c[0..32]])
    field valid = if encoded_prev_block_hash1 == prev_block_hash[0] && encoded_prev_block_hash2 == prev_block_hash[1] \
        then 1 else 0 fi

    field[256] preimage1 = [...a, ...b]
    field[256] preimage2 = [...c, ...d]
    field[256] preimage3 = [...[...e, 1], ...[0; 127]]
    field[256] dummy = [...[0; 246], ...[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]] //second array indicates length of preimage = 640bit

    intermediary = sha256for1024(preimage1, preimage2, preimage3, dummy)

    r = sha256only(intermediary)

    res0 = pack128(r[0..128])
    res1 = pack128(r[128..256])
/*
    field[8] unpacked_target_bytes = e[88..96]
    field target_bytes = pack128([...[0;120], ...unpacked_target_bytes])

    field[24] bigEndian_difficulty_bits = toBigEndian(e[64..88])
    field[128] unpacked_difficulty_bits = [...[0; 104], ...bigEndian_difficulty_bits]
	field difficulty_bits = pack128(unpacked_difficulty_bits)
*/
    target = unpackBits(toBigEndian(e[64..96]))

    valid = if valid == 1 && target > pack128(toBigEndian(r[128..256])) then 1 else 0 fi

//return [valid, res0, res1]
return [valid, target, pack128(toBigEndian(r[128..256]))] //output for test purposes

def main(field[2] prev_block_hash, private field[20] intermediate_blocks, field[5] final_block) -> (field[3]):

    field result = 1

    block1 = validate_block_header(prev_block_hash, intermediate_blocks[0..5])
    result = if block1[0] == 0 || result == 0 then 0 else 1 fi
/*
    block2 = validate_block_header(block1[1..3], intermediate_blocks[5..10])
    result = if block2[0] == 0 || result == 0 then 0 else 1 fi

    block3 = validate_block_header(block2[1..3], intermediate_blocks[10..15])
    result = if block3[0] == 0 || result == 0 then 0 else 1 fi

    block4 = validate_block_header(block3[1..3], intermediate_blocks[15..20])
    result = if block4[0] == 0 || result == 0 then 0 else 1 fi

    block5 = validate_block_header(block4[1..3], final_block)
    result = if block5[0] == 0 || result == 0 then 0 else 1 fi
*/
return block1